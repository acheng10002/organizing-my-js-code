/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger.js */ \"./src/logger.js\");\n// SINGLE RESPONSIBILITY PRINCIPLE\n\n// function that should check if a game over condition has been meet\n\n// the function and module it's in, should not directly be the one to manipulate the DOM\n/* like this...\nfunction isGameOver() {\n    game over logic goes here!\n\n    if (gameOver) {\n        DOMStuff.gameOver(this.winner);\n    }\n}\n*/\n\n/* isGameOver function should only be responsible for checking if the gameOver condition is met\nbased on isGameOver return value, the function that handles the game loop should be responsible \nfor deciding whether to call DOMStuff.gameOver(this.winner) or not\n*/\n// function isGameOver() {\n//     if (gameOver) {\n//         const gameOverDiv = document.createElement('div');\n//         gameOverDiv.classList.add('game-over');\n//         gameOverDiv.textContent = `${this.winner} wont he game!`;\n//         document.body.appendChild(gameOverDiv);\n//     }\n// }\n\nclass CalorieTracker {\n\n    // input daily maxCalories \n    constructor(maxCalories) {\n        this.maxCalories = maxCalories\n        this.currentCalories = 0\n    }\n\n// responsibility 1: tracking how calories are counted\n    // track calories by adding on calories passed to it, to currentCalories\n    trackCalories(calorieCount) {\n        this.currentCalories += calorieCount\n\n        // if currentCalories exceeds the max, logs message\n        if (this.currentCalories > this.maxCalories) {\n            (0,_logger_js__WEBPACK_IMPORTED_MODULE_0__.logMessage)('Max calories exceeded test test test test test')\n        }\n    }\n\n// responsibility 2: logging calories/notifying user of max being surpassed\n    // logCalorieSurplus() {\n    //     console.log('Max calories exceeded')\n    // }\n}\n\nconst calorieTracker = new CalorieTracker(2000)\ncalorieTracker.trackCalories(500)\ncalorieTracker.trackCalories(1000)\ncalorieTracker.trackCalories(700)\n\n\n// OPEN/CLOSED PRINCIPLE\n// takes an array of questions \nfunction printQuiz(questions) {\n    \n    // loops through the questions\n    questions.forEach(question => {\n        \n        // prints out each of the questions' descriptions\n        console.log(question.description)\n\n        // checks the question type, and depending on what type it is, it prints out different options \n        /* SWITCH STATEMENTS AND GIANT IF STATEMENTS ARE OFTEN \n        A VIOLATION OF THE OPEN/CLOSED PRINCIPLE */\n        switch (question.type) {\n            case 'boolean':\n                console.log('1. True')\n                console.log('2. False')\n                break\n            case 'multipleChoice':\n                question.options.forEach((option, index) => {\n                    console.log(`${index + 1}. ${option}`)\n                })\n                break\n            case 'text':\n                console.log('Answer: ________________________')\n                break\n\n            /* closed - if I am changing the code outside, like adding data, I should not need to change\n            the application logic inside\n            the printQuiz function should work with a new type, without me having to go in and change the logic \n            open - I do have the ability to create new types of things, to add a range type question without needing to make changes to the function */\n            case 'range':\n                console.log('Minimum: ________________________')\n                console.log('Maximum: ________________________')\n                break\n        }\n        console.log('')\n    })\n}\n\nconst questions = [\n    {\n        type: 'boolean',\n        description: 'This video is useful.'\n    },\n    {\n        type: 'multipleChoice',\n        description: 'What is your favorite language?',\n        options: ['CSS', 'HTML', 'JS', 'Python']\n    },\n    {\n        type: 'text',\n        description: 'Describe your favorite JS feature.'\n    },\n    {\n        type: 'range',\n        description: 'What is the speed limit in your city?'\n    }\n]\n\n/* instead, break up the code into individual classes: boolean, multipleChoice, text, and range,\nand the classes with handle the printing inside of them \n\nprintQuiz function will just call the print function inside the classes \nfor a new type, make a new class, and make that type know how to print itself */\n\nprintQuiz(questions)\n\n\n/* each class knows what to do with their type */\nclass BooleanQuestion {\n    constructor(description) {\n        this.description = description\n    }\n\n    printQuestionChoices() {\n        console.log('1. True')\n        console.log('2. False')\n    }\n}\n\nclass MultipleChoiceQuestion {\n    constructor(description, options) {\n        this.description = description\n        this.options = options\n    }\n\n    printQuestionChoices() {\n        this.options.forEach((option, index) => {\n            console.log(`${index + 1}. ${option}`)\n        })\n    }\n}\n\nclass TextQuestion {\n    constructor(description) {\n        this.description = description\n    }\n\n    printQuestionChoices() {\n        console.log('Answer: _____________________')\n    }\n}\n\nclass RangeQuestion {\n    constructor(description) {\n        this.description = description\n    }\n\n    printQuestionChoices() {\n        console.log('Minimum: _____________________')\n        console.log('Maximum: _____________________')\n    }\n}\n\n/* pritnQuiz2 stays closed when I add a new question and class for that question type \nprintQuiz2 abilities get extended but not modified */\nfunction printQuiz2(questions) {\n    questions.forEach(question => {\n        console.log(question.description)\n\n        // print out my question choice, which is a function each of my classes has \n        // this one function call does it!\n        question.printQuestionChoices()\n        console.log('')\n    })\n}\n\n// questions array now consists of instances of the classes\nconst questions2 = [\n    new BooleanQuestion('This video is useful.'),\n    new MultipleChoiceQuestion(\n        'What is your favorite language?',\n        ['CSS', 'HTML', 'JS', 'Python']\n    ),\n    new TextQuestion('Describe your favorite JS feature.'),\n    new RangeQuestion('What is the speed limit in your city?'),\n]\n\nprintQuiz2(questions2)\n/* instead of changing code, I want to create new code, and the new code will work with my old code\nto extend the old code's functionality */\n\n\n// LISKOV SUBSTITUION PRINCIPLE\n// create this object, that the rest of my objects can inherit from\nclass Shape {\n    area() {\n        // \n    }\n}\n\n// class Rectangle extends Shape\nclass Rectangle {\n    constructor(width, height) {\n        this.width = width\n        this.height = height\n    }\n    setWidth(width) {\n        this.width = width\n    }\n    setHeight(height) {\n        this.height = height\n    }\n    area() {\n        return this.width * this.height\n    }\n}\n\n// class Square extends Shape\nclass Square extends Rectangle {\n\n    // here, the width and height will always be the same for instances of Square\n    setWidth(width) {\n        this.width = width\n        this.height = width\n    }\n\n    setHeight(height) {\n        this.height = height\n        this.width = height\n    }\n}\n\n/* this function breaks the Liskov substitution principle:\nmy subclass of square is not actually compatible with every function that I'm using\nwhy? when I set width for square, I am also setting height which may alter the return value of area() \neasiest way to fix the problem is to change what I inherited from */\nfunction increaseRectangleWidth(rectangle) {\n    rectangle.setWidth(rectangle.width + 1)\n}\n\n// create new instances of Rectangle\nconst rectangle1 = new Rectangle(10, 2)\nconst square = new Square(5, 5)\n\n// increase width of the Rectangle instances\nincreaseRectangleWidth(rectangle1)\nincreaseRectangleWidth(square)\n\n// print out the new areas of the Rectangle instances\nconsole.log(rectangle1.area())\nconsole.log(square.area())\n\n// base class\nclass FlyingBird {\n    fly() {\n        console.log('I can fly')\n    }\n}\n\nclass SwimmingBird {\n    swim() {\n        console.log('I can swim')\n    }\n}\n\nclass Duck extends FlyingBird {\n    quack() {\n        console.log('I can quack')\n    }\n    // so add swimming and flying functionalities to my duck class instead of having it extend any base class\n}\n\n/* \n***problem: a duck can swim, but a subclass can't inherit from two parent classes\nwhy composition is better: add functionality instead of inheriting it\n*/\nclass Penguin extends SwimmingBird {\n}\n\nfunction makeFlyingBirdFly(bird) {\n    bird.fly()\n}\n\nfunction makeSwimmingBirdSwim(bird) {\n    bird.swim()\n}\nconst duck = new Duck()\nconst penguin = new Penguin()\n\n/* According Liskov principle, every subclass of a class must be able to make the function work\nproperly\nDuck class passes the Liskov substitution principle, but Penguin class doesn't  \n\nwith the FlyingBird class and SwimmingBird class,\nevery subclass of FlyingBird can properly call the fly() function and\nevery subclass of SwimmingBird can call the swim() function \n\neverything is working as if it were the parent class,\nthe code  \n\nIf I have a function that accepts a class, every subclass of that class must be able to enter\nthat function and work properly */\n\nmakeFlyingBirdFly(duck)\nmakeSwimmingBirdSwim(penguin)\n\n\n// INTERFACE SEGREGATION PRINCIPLE\n/* when I have a large interface like this, it does lots of different things\n\nwhenver I have an interface, I need everything that implements that interface to use every single\npart of the interface\n*/\n// interface Entity {\n       // properties of the interface\n//     attackDamage\n//     health\n//     name\n\n       // methods of the interface\n//     move()\n//     attack()\n//     takeDamage(amount)\n// }\n\n// every class that implements that interface needs to define all the methods in that interface\n// class Character implements Entity {\n//     move() {\n//         // do something\n//     }\n\n//     attack() {\n//         // do something\n//     }\n\n//     takeDamage(amount) {\n//         // do something\n//     }\n// }\n\n// class Turret implements Entity {\n//     move() {\n//         // ERROR: Cannot move\n//     }\n// }\n\n/* in JS, using classes and inheritance, instead of interfaces, is similar \n\nnow I have a class instead of an interface */\nclass Entity {\n    constructor(name, attackDamage, health) {\n        this.name = name\n        this.attackDamage = attackDamage\n        this.health = health\n    }\n\n    move() {\n        console.log(`${this.name} moved`)\n    }\n\n    attack(targetEntity) {\n        console.log(`${this.name} attacked ${targetEntity.name} for \n        ${this.attackDamage} damage`)\n        targetEntity.takeDamage(this.attackDamage)\n    }\n\n    takeDamage(amount) {\n        this.health -= amount\n        console.log(`${this.name} has ${this.health} health remaining`)\n    }\n}\n\nclass Character extends Entity {\n\n}\n\n// a wall cannot move or attack, so it has 0 for attackDamage\nclass Wall extends Entity {\n    constructor(name, health) {\n\n        /* super() calls the constructor of the parent class\n        done inside the constructor of the derived class to initialize the base class parts of the object */\n        super(name, 0, health)\n    }\n\n    move() {\n        return null\n    }\n\n    attack() {\n        return null\n    }\n}\n\nclass Turret extends Entity {\n    constructor(name, attackDamage) {\n        super(name, attackDamage, -1)\n    }\n\n    move() {\n        return null\n    }\n\n    takeDamage() {\n        return null\n    }\n}\n\nconst turret = new Turret('Turret', 5)\nconst character = new Character('Character', 3, 100)\nconst wall = new Wall('Wall', 200)\n\nturret.attack(character)\ncharacter.move()\ncharacter.attack(wall)\n// below won't throw an error\nturret.move()\n\nclass Entity1 {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\n// smaller components, smaller interfaces/classes\nconst mover = {\n    move() {\n        console.log(`${this.name} moved`)\n    }\n}\n\nconst attacker = {\n    attack(targetEntity) {\n        console.log(`${this.name} attacked ${targetEntity.name} for \n        ${this.attackDamage} damage`)\n        targetEntity.takeDamage(this.attackDamage)\n    }\n}\n\nconst hasHealth = {\n    takeDamage(amount) {\n        this.health -= amount\n        console.log(`${this.name} has ${this.health} health remaining`)\n    }\n}\n\nclass Character1 extends Entity1 {\n    constructor(name, attackDamange, health) {\n        super(name)\n        this.attackDamage = this.attackDamage\n        this.health = health\n    }\n}\n\n// taking the protoype, which is basically the definition of my class, and adding in different functionalities\nObject.assign(Character1.prototype, mover)\nObject.assign(Character1.prototype, attacker)\nObject.assign(Character1.prototype, hasHealth)\n\nclass Wall1 extends Entity1 {\n    constructor(name, health) {\n        super(name)\n        this.health = health\n    }\n}\n\nObject.assign(Wall1.prototype, hasHealth)\n\nclass Turret1 extends Entity1 {\n    constructor(name, attackDamage) {\n        super(name)\n        this.attackDamage = attackDamage\n    }\n}\n\nObject.assign(Turret1.prototype, attacker)\n\nconst turret1 = new Turret1('Turret', 5)\nconst character1 = new Character1('Character', 3, 100)\nconst wall1 = new Wall1('Wall', 200)\n\nturret1.attack(character1)\ncharacter1.move()\ncharacter1.attack(wall1)\n\n// below will throw TypeErrors because the objects/classes don't implement the methods it cannot use\n// turret1.move()\n// wall1.move()\n\n/* THIS REVIEW */\n\n/* Global Context - this refers to the global object whether in strict mode or not */\nconsole.log(undefined === window); // true\n\n/* Inside a Function - in non-strict mode, this defaults to the global object; it strict-mode, this will be undefined */\nfunction regularFunction() {\n    console.log(this);\n}\n\nregularFunction(); // 'window' in non-strict mode, 'undefined' in strict mode\n\n/* Inside a Method - this refers to the object that the method belongs to */\nconst obj = {\n    method: function() {\n        console.log(this); \n    }\n};\n\nobj.method(); // 'obj'\n\n/* Event Handlers - this will be set to the DOM element that is handling the event \nbutton.addEventListener('click', function() {\n    console.log(this); // 'button'\n}); */\n\n/* Constructor Functions - this refers to the newly created object */\n// constructor function constructs Person object\nfunction Person(name) {\n    this.name = name;\n}\n\n// alice stores new instance of Person object, whose name property is \"Alice\"\nconst alice = new Person(\"Alice\");\nconsole.log(alice.name); // \"Alice\"\n\n/* Arrow Functions - don't have their own this value; they're lexically scoped, inheriting \n                     this from the enclosing scope at the time of creation */\nconst obj1 = {\n    value: 42,\n    arrowFunction: () => {\n        console.log(undefined); // refers to the outer scope's 'this'\n    }\n};\n\nobj1.arrowFunction(); // 'window' in non-strict mode, 'undefined' in strict mode\n\n/* Explicit Setting - 'this; can be explicitly set with methods like call, apply, and bind */\nfunction logThis() {\n    console.log(this);\n}\n\nconst obj2 = { value: 42 };\n\nlogThis.call(obj); // sets 'this' to 'obj' within the function\n\n/* Classes - in ES6 classes, 'this' inside methods is automatically set to point to the object\n             instance of the class */\nclass MyClass {\n    constructor(value) {\n        this.value = value;\n    }\n\n    logValue() {\n        console.log(this.value);\n    }\n}\n\nconst instance = new MyClass(42);\ninstance.logValue(); // ('this' is) 42\n\n\n// DEPENDENCY INVERSION PRINCIPLE \nclass Store {\n    constructor(user) {\n        // Stripe does take in the user object to to create a new Stripe object\n        // this.stripe = new Stripe(user)\n        // Paypal doesn't take the user object\n        this.paypal = new Paypal()\n\n        // I need to create a user variable since Paypal doesn't take a user \n        this.user = user\n        // create a new Stripe object that allows me to access the Stripe class directly\n        // this.stripe = new Stripe(user)\n    }\n\n    purchaseBike(quantity) {\n        this.paypal.makePayment(this.user, 200 * quantity)\n        // call the Stripe object/API to make a payment\n        // Stripe wants the amount in pennies\n        // this.stripe.makePayment(200 * quantity * 100)\n    }\n\n    purchaseHelmet(quantity) {\n        this.paypal.makePayment(this.user, 15 * quantity)\n        // this.stripe.makePayment(15 * quantity * 100)\n    }\n}\n\n// this is the Stripe API\nclass Stripe {\n    // Stripe API/class takes in the user; I'm going to makePayments on the user\n    constructor(user) {\n        this.user = user\n    }\n\n    makePayment(amountInCents) {\n        console.log(`${this.user} made payment of $${amountInCents / 100} with Stripe`)\n    }\n}\n\n// unlike Stripe, Paypal doesn't take in user in the constructor (instea it takes it in the makePayment method)\nclass Paypal {\n    makePayment(user, amountInDollars) {\n        console.log(`${user} made payment of $${amountInDollars} with PayPal`)\n    }\n}\n\n// implementation details calling Store\nconst store = new Store('John')\nstore.purchaseBike(2)\nstore.purchaseHelmet(2)\n\n/* make an intermediate API, that has the same functions, same methods, same interface \nas the Stripe and the Paypal APIs */\nclass Store1 {\n    // new class of paymentProcessor\n    constructor(paymentProcessor) {\n        // paymentProcessor will always take in the user in the constructor\n        this.paymentProcessor = paymentProcessor\n    }\n\n    purchaseBike(quantity) {\n        // pay function takes in the amount in dollars (pay is a method of the paymentProcessor class)\n        this.paymentProcessor.pay(200 * quantity)\n    }\n\n    purchaseHelmet(quantity) {\n        this.paymentProcessor.pay(15 * quantity)\n    }\n}\n\n// this is the intermediate API that wraps the Stripe dependency\n// Stripe1 is being passed into the StripePaymentProcessor, and the StripePaymentProcessor is being passed into Store1\nclass StripePaymentProcessor {\n    // this constructor needs to match the class created in Store1\n    constructor(user) {\n\n    // this StripePaymentProcessor is passing off all of my function calls to the Stripe1 API\n        this.stripe = new Stripe1(user)\n    }\n\n    pay(amountInDollars) {\n\n        // because Stripe needs the amountInCents\n        this.stripe.makePayment(amountInDollars * 100)\n    }\n}\n\n/* this is the Stripe1 API, the actual implementation\nmy store will call methods on the payment processor, \nbut the payment processor methods will actually call the Stripe1 API */\nclass Stripe1 {\n    // I'm going to makePayments on the user\n    constructor(user) {\n        this.user = user\n    }\n\n    makePayment(amountInCents) {\n        console.log(`${this.user} made payment of $${amountInCents / 100} with Stripe`)\n    }\n}\n\n// this is the intermediate API that wraps the Paypal dependency \nclass PaypalPaymentProcessor {\n    constructor(user) {\n        this.user = user\n        this.paypal = new Paypal()\n    }\n\n    pay(amountInDollars) {\n        this.paypal.makePayment(this.user, amountInDollars)\n    }\n}\n\n// this is the Paypal API, the actual implementation\nclass Paypal1 {\n    makePayment(user, amountInDollars) {\n        console.log(`${user} made payment of $${amountInDollars} with PayPal`)\n    }\n}\n\n// implementation details calling Store1\nconst store1 = new Store1(new PaypalPaymentProcessor('John'))\nstore1.purchaseBike(2)\nstore1.purchaseHelmet(2)\n\n/* the payment processor classes are wrappers around the external dependencies, and my\ncode ends up depending on the wrappers not the implementation of the external dependencies */\n\n// FACTORY FUNCTIONS AND CONSTRUCTOR/CLASSES - both used to create objects \n\n/* Factory Function\n- don't rely on `this`; `this` within methods refers to the object that the methos is called on, if invoked as methods\n- not built for inheritance, although possible with some manual linking \n- objects won't be an instance of a factory\n- no easy way to check the \"type\" of object, unless manually added\n- easier to create truly private variables\n- simpler and more straightforward object creation for simple cases \n*/\nfunction createPerson1(name, age) {\n    return {\n        name,\n        age,\n        sayHello: function() {\n            console.log(`Hello, my name is ${this.name}`);\n        }\n    };\n}\n\nconst person1 = createPerson1('Alice', 30);\n\n/* Constructor Function\nConstructors/Classes \n- `this` is automatically set to the new object being created when using the new keyword \n- in ES6 classes, methods are added to the class's prototype, \n   and `this` within methods refers refers to the instance when invoked as methods \n- designed with inheritance in mind, using the `prototype` for shared behaviors and `extends` in classes \n- objects are instances of the constructor/class\n- can use `instanceof` to check the type\n- require workarounds to create private variables, but ES^ classes are getting private class fields \n- provide better structure and organization for larger projects, especially when using `extends` for inheritance */\nfunction Person2(name, age) {\n    this.name = name;\n    this.age = age;\n    this.sayHello = function() {\n        console.log(`Hello, my name is ${this.name}`);\n    };\n}\n\nconst person2 = new Person2('Alice', 30);\n\n// Class (Constructor under the hood)\nclass Person3 {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    sayHello() {\n        console.log(`Hello, my name is ${this.name}`);\n    }\n}\n\nconst person3 = new Person3('Alice', 30);\n\n// SINGLE RESPONSIBILITY PRINCIPLE\n/* a class or module should only have a single purpose */\nclass Car {\n    constructor(make, model) {\n        this.make = make;\n        this.model = model;\n    }\n\n    // depending on some logic, the car may or may not start when start() is called\n    start() {\n        if (Car) { // logic to determine whether or not the car should start\n            this.errorLog(`The car ${this.make} ${this.model} started.`);\n            return true;\n        }\n        this.errorLog(`The car ${this.make} ${this.model} failed to start.`);\n        return false;\n    }\n\n    // depending on the outcome, the class will then log some info\n    errorLog(message) {\n        console.log(message);\n    }\n}\n\n/* logic for logging info should not be a responsibility of the Car class\nmy logger method logs to a file, but suddenly an update occurs on the underlying system that the \ncar class is running on... I need to change the way I write to files\nI now need to update every file writing instance of every class I've ever implemented a logger of\n\n\nso instead, here the logger is stored in a separate class, meaning its functionality is separate from\nthe Car1 class */\nclass ErrorLog1 {\n    static log(message) {\n        console.log(message);\n    }\n}\n\n// this Car1 class can be changed, moved around, or even deleted without affecting the logger class  \nclass Car1 {\n    constructor(make, model) {\n        this.make = make;\n        this.model = model;\n    }\n\n    start() {\n        if (Car1) { // logic to determine whether or not the car should start\n            ErrorLog1.log(`The car ${this.make} ${this.model} started.`);\n            return true;\n        }\n        ErrorLog1.log(`The car ${this.make} ${this.model} failed to start.`);\n        return false;\n    }\n}\n\n// HIGHLY SCALABLE AND MAINTAINABLE JS: COUPLING \n// Ex: Create Order\n// order module definition\n// ordering module has functions to create, read, update, and delete orders (i.e. CRUD)\nvar orderModule = (function() {\n    var module = {},\n        deliveries = myApp.deliveryModule;\n    // user places an order and app creates the order\n    module.createOrder = function(orderData) {\n        var orderResult;\n\n        orderResult = // code to actually create the order\n        // send a confirmation to the user that includes the estimated time of delivery\n        orderResult.estimatedDeliveryTime = deliveries.getDeliveryTime(orderData);\n\n        return orderResult;\n    };\n\n    return module;\n})();\n\n// user can check the status or cancel the order at any time? \n\n/* deliveries module has functions to estimate delivery time, begin delivery, complete delivery, etc.\n\norder and delivery modules are tightly coupled - for the order module to get the estimated delivery time, \nit has to \"know\" about the delivery module, and call the appropriate module's API\n\n- I want to be able to easily swap out any module for a different module\n- I want to be able to test modules independently\n- I want to maximize code reuse\n- there should not be a single point of failure anywhere in the app \n   something goes wrong in my call to get the estimated delivery time, I do not want to break the\n   successful completion of the ordering process or the entire app\n   I want the order to still be placed, even if I temporarily cannot provide a delivery time estimate\n\nPatterns to Reduce Coupling\n- often variations of the observer pattern\nex. Publish/Subscribe pattern\nmany versions of the Pub/Suc pattern involve a mediator object, which helps to minimize coupling between modules\nthe mediator object isolates the publisher from the subscriber\n\ntopic-based JS Pub/Sub library - there are topics that a module can subscribe to, publish to, or both, and a module\n                                 is also able to unsubscribe from a topic if needed\n*/\n\n// Ex: Estimated delivery time using Pub/Sub pattern\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n    var orderModule = (function() {\n        var orders = {},\n            // define a topic with the constant\n            // any module can publish and/or subscribe to this topic without knowing of each other's existence \n            EST_DELIVERY = 'current estimated delivery time',\n            // call the getEstimatedDeliveryTime method of the delivery module\n            estimatedDeliveryTime;\n\n            // order module subscribes to the topic and will always have the most up-to-date estimated delivery wait time\n            PubSub.subscribe(EST_DELIVERY, function(msg, data) {\n                console.log(msg);\n                estimatedDeliveryTime = data;\n\n            // I can implement a mechanism that regularly updates and publishes the estimated delivery wait time to this topic\n            });\n\n            return orders;\n    })();\n\n    var deliveryModule = (function() {\n        var deliveries = {},\n            EST_DELIVERY = 'current estimated delivery time';\n\n        deliveries.getEstimatedDeliveryTime = function() {\n            var estimatedDeliveryTime = 1; // hard-coded to 1 hour, but likely an API call\n\n            PubSub.publish(EST_DELIVERY, estimatedDeliveryTime);\n        };\n\n        return deliveries;\n    })();\n\n    deliveryModule.getEstimatedDeliveryTime();\n});\n\n/* Pub/Sub pattern - messaging pattern that enables decoupling between publishers and subscribers;\n                     it manages event handling and messaging among loosely-coupled components\n   publishers - components that emit events\n   subscribers - components that consume those events */\n// object or service that keeps track of subscriptions and events and takes care of forwarding a\n// published event to all its subscribers\nconst eventChannel = {\n    events: {},\n\n    subscribe: function(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    },\n\n    publish: function(eventName, data) {\n        if (this.events[eventName]) {\n            this.events[eventName].forEach(listener => listener(data));\n        }\n    }\n};\n\n// Subscriber\neventChannel.subscribe('event1', (data) => {\n    console.log(`Event1 received with data: ${data}`);\n});\n\n// Publisher\neventChannel.publish('event1', 'some data'); // \"Event1 received with data: some data\"\n\n//# sourceURL=webpack://oop-principles/./src/index.js?");

/***/ }),

/***/ "./src/logger.js":
/*!***********************!*\
  !*** ./src/logger.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   logMessage: () => (/* binding */ logMessage)\n/* harmony export */ });\nfunction logMessage(message) {\n    console.log(message);\n\n    // alternatively, could email the user\n}\n\n\n\n//# sourceURL=webpack://oop-principles/./src/logger.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;