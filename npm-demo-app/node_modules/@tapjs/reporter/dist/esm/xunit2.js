// xunit v2 representation of the test run
// https://xunit.net/docs/format-xml-v2
import { randomBytes } from 'crypto';
import { Minipass } from 'minipass';
import { Parser } from 'tap-parser';
import { stringify } from 'tap-yaml';
const xmlEscape = (s) => s
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
const cdata = (s) => s
    .split(']]>')
    .map(s => `<![CDATA[\n${s.trimEnd()}\n]]>`)
    .join(xmlEscape(']]>'));
class Properties {
    data;
    constructor(data) {
        this.data = data;
    }
    toString() {
        /* c8 ignore start */
        if (!this.data)
            return '';
        /* c8 ignore stop */
        const body = Object.entries(this.data)
            .map(([k, v]) => {
            if (v === undefined ||
                v === null ||
                v === '' ||
                v === false) {
                return '';
            }
            else {
                return `<trait name="${xmlEscape(k)}" value="${xmlEscape(v)}" />`;
            }
        })
            .filter(v => !!v);
        if (!body.length)
            return '';
        return `<traits>
${body.join('\n')}
</traits>`;
    }
}
class Failure {
    result;
    constructor(result) {
        this.result = result;
    }
    toString() {
        const msg = stringify({
            ...(this.result.diag || { name: this.result.name }),
        });
        return `<failure>${cdata(msg).trimEnd()}</failure>`;
    }
}
class Case {
    result;
    classname;
    constructor(result) {
        this.result = result;
        const fn = result.fullname;
        /* c8 ignore start */
        this.classname = fn.endsWith(result.name)
            ? fn
                .substring(0, fn.length - result.name.length)
                .replace(/>? $/, '')
                .trimEnd()
            : fn;
        /* c8 ignore stop */
    }
    get failures() {
        return this.result.ok ? 0 : 1;
    }
    get skipped() {
        return this.result.skip || this.result.todo ? 1 : 0;
    }
    get tests() {
        return 1;
    }
    toString() {
        /* c8 ignore start */
        const file = this.result.diag?.at?.fileName ||
            this.result.diag?.at?.file ||
            this.result.diag?.file;
        const line = this.result.diag?.at?.lineNumber ||
            this.result.diag?.at?.line ||
            this.result.diag?.line;
        const column = this.result.diag?.at?.columnNumber ||
            this.result.diag?.at?.column ||
            this.result.diag?.column;
        /* c8 ignore stop */
        const { ok, name, skip, todo, tapError, time, diag } = this.result;
        const props = String(new Properties({
            ...(skip ? { skip } : {}),
            ...(todo ? { todo } : {}),
            /* c8 ignore start */
            ...(tapError ? { tapError } : {}),
            /* c8 ignore stop */
            ...(diag || {}),
        })).trimEnd();
        return `<testcase id="${this.result.id}" name="${xmlEscape(name)}" classname="${xmlEscape(this.classname)}"${time ? ` time="${seconds(time)}"` : ''}${file ? ` file="${xmlEscape(String(file))}"` : ''}${file && line ? ` line="${xmlEscape(String(line))}"` : ''}${file && line && column
            ? ` column="${xmlEscape(String(column))}"`
            : ''}${ok && !props
            ? ' />'
            : `>
${!ok ? new Failure(this.result) : props}
</testcase>
`}`;
    }
}
class Suite {
    parser;
    suites = [];
    cases = [];
    name;
    results;
    startRTF = new Date().toISOString();
    finishRTF;
    constructor(parser) {
        this.parser = parser;
        this.name = parser.name;
        this.parser.on('complete', res => (this.results = res));
        this.parser.on('child', p => this.suites.push(new Suite(p)));
        this.parser.on('assert', a => this.onAssert(a));
    }
    onAssert(a) {
        this.cases.push(new Case(a));
    }
    get tests() {
        return ([...this.suites, ...this.cases]
            .map(s => s.tests)
            /* c8 ignore start */
            .reduce((a, b) => a + b, this.results ? 1 : 0));
        /* c8 ignore stop */
    }
    get failures() {
        return [...this.suites, ...this.cases]
            .map(s => s.failures)
            .reduce((a, b) => a + b, this.results?.ok === false ? 1 : 0);
    }
    get assertions() {
        return this.suites
            .map(s => s.assertions)
            .reduce((a, b) => a + b, this.cases.length);
    }
    get passed() {
        return this.assertions - this.skipped - this.failures;
    }
    get skipped() {
        return [...this.suites, ...this.cases]
            .map(s => s.skipped)
            .reduce((a, b) => a + b, this.results?.plan.skipAll ||
            this.results?.skip ||
            this.results?.todo
            ? 1
            : 0);
    }
    toString() {
        const props = new Properties({
            ok: this.results?.ok,
            plan: this.results?.plan,
            bailout: this.results?.bailout,
            tests: this.tests,
            failures: this.failures,
            assertions: this.assertions,
            duration: this.results?.time,
        });
        const finish = new Date();
        const id = randomBytes(6).toString('hex');
        const resTime = this.results?.time;
        const time = resTime ? ` time="${seconds(resTime)}"` : '';
        const timeRTF = resTime
            ? ' time-rtf="' +
                String(Math.floor((resTime / 1000) * 60 * 60)).padStart(2, '0') +
                ':' +
                String(Math.floor((resTime / 1000) * 60)).padStart(2, '0') +
                ':' +
                String(Math.floor(resTime / 1000)).padStart(2, '0') +
                '.' +
                String(Math.floor(resTime) - resTime).padEnd(6, '0') +
                '"'
            : '';
        return `<assembly name="${xmlEscape(this.name)}" id="${id}" start-rtf="${this.startRTF}" finish-rtf="${finish.toISOString()}" timestamp="${finish.toLocaleString('en')}" failed="${this.failures}" not-run="${this.skipped}" passed="${this.passed}" run-date="${this.startRTF.substring(0, 'YYYY-MM-DD'.length)}" run-time="${this.startRTF.substring('YYYY-MM-DDT'.length, 'YYYY-MM-DDTHH:MM:SS'.length)}" test-framework="node-tap"${time}${timeRTF} total="${this.cases.length}">
${props}
${this.suites
            .map(s => String(s))
            .join('\n')
            .trimEnd()}
${this.cases
            .map(c => String(c))
            .join('\n')
            .trimEnd()}
</assembly>
`;
    }
}
class Suites extends Suite {
    onAssert() { }
    toString() {
        const finish = new Date();
        const id = new Date()
            .toISOString()
            .replace(/[^0-9T]/g, '')
            .replace('T', '_');
        return `<assemblies id="${xmlEscape(id)}" start-rtf="${this.startRTF}" finish-rtf="${finish.toISOString()}" timestamp="${finish.toLocaleString('en')}" schema-version="2">
${this.suites
            /* c8 ignore stop */
            .map(s => String(s))
            .join('\n')
            .trimEnd()}
</assemblies>
`;
    }
}
const seconds = (m) => m === undefined ? '' : String(Math.floor(m * 1000) / 1000000);
export class XUnit2 extends Minipass {
    parser = new Parser();
    constructor() {
        super({ encoding: 'utf8' });
        super.write('<?xml version="1.0" encoding="UTF-8" ?>\n');
        const suites = new Suites(this.parser);
        this.parser.on('complete', () => {
            super.write(String(suites));
            super.end();
        });
    }
    write(chunk, encoding, cb) {
        return this.parser.write(chunk, encoding, cb);
    }
    end(chunk, encoding, cb) {
        this.parser.end(chunk, encoding, cb);
        return this;
    }
}
//# sourceMappingURL=xunit2.js.map