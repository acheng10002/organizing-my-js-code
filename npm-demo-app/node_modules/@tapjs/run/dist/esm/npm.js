/**
 * some utilities for interfacing with npm in the `tap plugin` command
 */
import { foregroundChild } from 'foreground-child';
import { spawnSync } from 'node:child_process';
const npmFreeEnv = Object.fromEntries(Object.entries(process.env).filter(([k]) => !/^npm_/i.test(k)));
/**
 * Run an npm command in the background, returning the result
 */
export const npmBg = (args, config) => spawnSync('npm', ['--prefix', config.globCwd, ...args], {
    env: npmFreeEnv,
    encoding: 'utf8',
    cwd: config.globCwd,
});
/**
 * Run an npm command in the foreground
 */
const npmFg = (args, config, cb) => foregroundChild('npm', ['--prefix', config.globCwd, ...args], {
    env: npmFreeEnv,
    cwd: config.globCwd,
}, cb);
// arguments when
const quiet = ['--no-audit', '--loglevel=error', '--no-progress'];
export const install = async (pkgs, config) => {
    const args = ['install', ...quiet, '--save-dev', ...pkgs];
    await new Promise((res, rej) => {
        npmFg(args, config, (code, signal) => {
            // allow error exit to proceed
            if (code || signal) {
                rej(Object.assign(new Error('install failed'), { code, signal }));
                return;
            }
            res();
            // do not exit
            return false;
        });
    });
};
export const uninstall = async (pkgs, config) => {
    const args = ['rm', ...quiet, ...pkgs];
    await new Promise(res => {
        npmFg(args, config, (code, signal) => {
            // allow error exit to proceed
            res();
            return code || signal ? undefined : false;
        });
    });
};
//# sourceMappingURL=npm.js.map